= Bases de Datos I: Trabajo Práctico 1
Liz Moreno López <lilita.moreno@hotmail.com>; Micaela Vera <micavera2010@hotmail.com>; Verónica Juarez <veronicajuarez01@hotmail.com>
{docdate}. Docentes Hernán Rondelli y Mariano Trigila (COM-01)
:numbered:
:source-highlighter: highlight.js
:tabsize: 4

El presente documento consiste en describir el diseño de un modelo de datos relativo a operaciones de tarjetas de crédito identificando las _primary key_ y _foreign key_ de cada schema creado. 

Este modelo debe cumplir los siguientes requisitos:

- Autorización de la compra.
- Generación de la factura. 
- Alerta a clientes.

//Se debe ser breve, conciso, y simple. Se debe incluir sólo lo relevante que ayude a entender el trabajo práctico. Ok

== Introducción

Las tarjetas no permiten a los usuarios financiar una compra en cuotas, todo se realiza en un solo pago. Una persona puede tener más de una tarjeta pero no deben existir extensiones de la misma. Las tarjetas podrán estar expiradas en su fecha de vencimiento.
Las tarjetas tendrán consumos que deben surgir a partir de las compras que se realicen en los distintos comercios. 
También, nos interesan los datos de los clientes, de las tarjetas de crédito con sus vencimientos y límites, entre otros. 

A partir de los datos de una compra, se puede aceptar o rechazar dicha compra. Se debe considerar distintos factores para la autorizacion de la compra; debe existir el número de la tarjeta y corresponder a alguna tarjeta vigente, el código de seguridad tiene que ser el correcto, el monto total de las compras pendientes de pago más la compra a realizar no debe superar el límite de compra de la tarjeta, por último, la tarjeta no debe estar vencida ni suspendida.

Para cada nuevo consumo se deben guardar los datos de una factura con el nombre y apellido, dirección, número de tarjeta, período de la factura, fecha de vencimiento, todas
las compras del período, y total a pagar.

Por último, se deben generar alertas por posibles fraudes. Existe un Call Center que ante cada alerta generada automáticamente realiza un llamado telefónico al cliente, indicándole la alerta detectada y verifica si se trató de un fraude ó no.
Se debe tener en cuenta para las alertas:

- Si una tarjeta registra dos compras en un lapso menor de un minuto en comercios distintos ubicados en el mismo código postal.
- Si una tarjeta registra dos compras en un lapso menor de 5 minutos en comercios con diferentes códigos postales.
- Si una tarjeta registra dos rechazos por exceso de límite en el mismo día, la tarjeta tiene que ser suspendida preventivamente.

//*(Longitud: 3–5 párrafos)*

== Descripción

En este apartado explicaremos las dificultades que tuvimos a lo largo de la realización del trabajo práctico.


//En esta sección pueden incluirse las dificultades que tuvieron, las soluciones encontradas, y las decisiones que fueron tomando a lo largo del trabajo práctico.

//También, se debe incluir una descripción general del programa—cómo funciona.

*(Longitud: 3–5 párrafos)*

== Implementación
A continuación se exponen los schemas de las tablas diseñadas como así la explicación de los atributos incorporados en dichas tablas. Además, se especificarán las correspondientes *Primary Key* (_PK_) y *Foreign Key* (_FK_) de cada tabla.

=== Tabla cliente
En primer lugar, diseñamos una tabla *cliente*, los atributos que tienen lugar en este modelo son el _dni_ que será el identificador único de dicha tabla, es decir, es la _primary key_. Luego, se tienen los datos necesarios del cliente, los cuales son el _nombre_, _apellido_ y la _dirección_, además, se debe especificar el _número de teléfono_ para que el Call Center pueda notificar al cliente de un posible fraude con su tarjeta.

[source, sql]
----
create table cliente(
        dni integer,
        nombre varchar(64),
        apellido varchar(64),
        direccion varchar(64),
        telefono integer
);   
----

Como nombramos anteriormente, el dni del cliente es una _primary key_ y agregamos este valor en la tabla con la siguiente sentencia:

[source, sql]
----
alter table cliente add constraint cliente_pk primary key (dni); 
----


=== Tabla tarjeta
*Tarjeta* es una tabla cuya _primary key_ es el número identificatorio de dicha tarjeta que consta de 16 dígitos, otro de los atributos de este schema es el propietario de la tarjeta, es decir,  el dni del cliente. Este sería la _FK_ de dicha tabla. 

//Aclaramos que el dni del cliente es la FK de la tarjeta y no de manera inversa, ya que en el enunciado se especifico que un cliente puede tener mas de una tarjeta.

Además, se tiene el _código de seguridad_ que consta de 3 a 4 dígitos dependiendo del banco, el _límite de compra_ diario de la tarjeta, es decir, el tope máximo que el banco financia a través de la tarjeta de crédito.
Colocamos un atributo denominado _fecha_vencimiento_ que se refiere a la fecha de expiracion de la tarjeta.

Por ultimo, el número de la tarjeta debe corresponder a una tarjeta vigente, no debe estar vencida, ni suspendida. La suspensión ocurre cuando la tarjeta registra dos rechazos por exceso de límite en el mismo dìa.

Para abarcar todos los estados de la tarjeta, incorporamos un atributo _estado_tarjeta_ en la tabla.

*falta agregar mas cosas*

[source,sql]
----
create table tarjeta(
       numero_tarjeta integer,
       dni_cliente integer,
       codigo_seguridad integer,
       limite_compra integer,
       saldo real,
       fecha_vencimiento date,
       estado_tarjeta varchar(64)      
);
----

El número de la tarjeta es la _PK_ de la tabla y se define de la siguiente manera:

[source,sql]
----
alter table tarjeta add constraint tarjeta_pk primary key (codigo_tarjeta);
----

Agregamos el dni del cliente como _FK_ de la siguiente manera:

[source,sql]
----
alter table tarjeta add constraint tarjeta_fk0 foreign key (dni_cliente) references cliente(dni);
----


=== Tabla comercio
Agregamos la tabla *comercio* que consta de distintos atributos, un numero identificatorio de comercio que denominamos _codigo_comercio_, el nombre, dirección y el codigo postal de dicho comercio.
Colocamos el codigo postal del comercio en caso de emitir una alerta en el momento que la tarjeta registre compras en el mismo o diferente codigo postal de los comercios en el transcurso de un tiempo dado.

[source,sql]
----
create table comercio(
        codigo_comercio integer,
        nombre varchar(64),
        direccion varchar(64),
        codigo_postal integer
); 
----

Añadimos la _PK_ de la tabla comercio con la siguiente sentencia:

[source,sql]
----
alter table comercio add constraint comercio_pk primary key (codigo_comercio);
----

=== Tabla compra
La tabla compra  cuya _primary key_ es el número identificario de dicha compra que consta de 3 a 4 dígitos, otros de los atributos de este schema es el _numero_tarjeta_  del cliente ya que el pago de la compra se
realiza con la tarjeta de crédito. Además tenemos el atrubito _horario_ que se refiere a las compras en un lapso de tiempo como ya mencionamos en la introducción.

[source,sql]
----
create table compra(
	    codigo_compra integer,
		numero_tarjeta integer,
		fecha date,
		horario time
);
----
El código de la compra es la _PK_ de la tabla y se define de la siguiente manera:

[source,sql]
----
alter table compra add constraint compra_pk primary key (codigo_compra);
----


=== Tabla factura
Una *factura* es un documento de índole comercial que indica la compra-venta de un bien o servicio, tiene validez legal y fiscal, entre otras cosas, debe incluir toda la información de la operación.
Entre la informacion que incluye una factura son el _codido_factura_ que es la _primary key_ de la tabla, el siguiente atributo es el _dni_cliente_, además el _codigo_comercio_  que es la _foreign key_ de la tabla. 
Como toda *factura*, esta incluye _detalle_artictulo_ que tambien es la _FK_ de la tabla.
[source,sql]
----
create table factura(
	    codigo_factura integer,
		dni_cliente integer,
		codigo_comercio integer,
		total_pagar real,
		detalle_articulo integer
);
----
//detalle es la fk de factura ---- ver si compra contiene a factura o viceversa. \creo que no\
}
Añadimos la PK de la tabla factura de la siguiente manera:
[source,sql]
----
alter table factura add constraint factura_pk primary key (codigo_factura);
----
También  añadimos las FK de la tabla factura de la siguiente manera:
[source,sql]
----
alter table factura add constraint factura_fk0 foreign key (dni_cliente) references cliente (dni);
alter table factura add constraint factura_fk1 foreign key (detalle_articulo) references detalle(codigo_articulo);
----



=== Tabla detalle
El *detalle* de la factura generalmente se encuentra en el centro de la misma. La _primary key_ de esta tabla es _codigo_articulo_ que el número identificatorio de articulo comprado.
además tiene los siguientes atributos: _cantidad_ se refiere a la cantidad de artículos, el _precio_unitario_ del artículo.
[source,sql]
----
create table detalle(
	    codigo_articulo integer,
		cantidad integer,
		precio_unitario real
);
----
Añadimos la _PK_ del detalle de la siguiente manera:
[source,sql]
----
alter table detalle add constrain detalle_pk primery key (codigo_articulo);
----

=== Tabla resumen
El *resumen* de la *tarjeta* es cuyo documento donde se encuentran toda la información de las compras  con el _total_pagar_ . 
La tabla *resumen* cuyas  _foreign key_ son:  _codigo_factura_, _numero_tarjeta_. Otros atributos de la tabla son: _periodo_facturado_  se refiere 
al tiempo desde que se inician las facturas de cada mes, hasta que finalizan es _fecha_vencimiento_. 


[source,sql]
----
create table resumen(
	    codigo_factura integer,
		periodo_facturado integer,
		fecha_vencimiento date,
		total_pagar real,
		numero_tarjeta integer
);		

----
Añadimos las _FKs_ de tabla resumen de la siguiente manera:
[source,sql]
----
alter table resumen add constraint detalle_fk0 foreign key (codigo_factura) references factura(codigo_factura);
alter table resumen add constraint detalle_fk1 foreign key (numero_tarjeta) references tarjeta(numero_tarjeta);
----


//En esta sección se incluye el código fuente correctamente formateado—y comentado, si corresponde. Además, por cada fragmento de código relevante—i.e. función, método, procedimiento—se debe dar una descripción general, decir qué hace, y especificar los parámetros que toma la función/método/procedimiento, junto con los valores que devuelve ó modifica.

//_No debería incluirse el código de librerías/frameworks que se utilicen—a no ser que sea absolutamente necesario._

*(Longitud: lo que sea necesario)*

== Conclusiones

//Aquí van algunas reflexiones acerca del proceso de desarrollo del trabajo realizado, y de los resultados obtenidos. También se debe incluir una conclusión final de producto terminado.

//Pueden incluirse lecciones aprendidas durante el desarrollo del trabajo.

*(Longitud: 1–3 párrafos)*
