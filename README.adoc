= Bases de Datos I: Trabajo Práctico 1
Liz Moreno López <lilita.moreno@hotmail.com>; Micaela Vera <micavera2010@hotmail.com>; Verónica Juarez <veronicajuarez01@hotmail.com>
{docdate}. Docentes Hernán Rondelli y Mariano Trigila (COM-01)
:numbered:
:source-highlighter: highlight.js
:tabsize: 4

El presente documento consiste en describir el diseño de un modelo de datos relativo a operaciones de tarjetas de crédito identificando las _primary key_ y _foreign key_ de cada schema creado. 

Este modelo debe cumplir los siguientes requisitos:

- Autorización de la compra.
- Generación de la factura. 
- Alerta a clientes.

//Se debe ser breve, conciso, y simple. Se debe incluir sólo lo relevante que ayude a entender el trabajo práctico. Ok

== Introducción

Las tarjetas no permiten a los usuarios financiar una compra en cuotas, todo se realiza en un solo pago. Una persona puede tener más de una tarjeta pero no deben existir extensiones de la misma. Las tarjetas podrán estar expiradas en su fecha de vencimiento.
Las tarjetas tendrán consumos que deben surgir a partir de las compras que se realicen en los distintos comercios. 
También, nos interesan los datos de los clientes, de las tarjetas de crédito con sus vencimientos y límites, entre otros. 

A partir de los datos de una compra, se puede aceptar o rechazar dicha compra. Se debe considerar distintos factores para la autorizacion de la compra; debe existir el número de la tarjeta y corresponder a alguna tarjeta vigente, el código de seguridad tiene que ser el correcto, el monto total de las compras pendientes de pago más la compra a realizar no debe superar el límite de compra de la tarjeta, por último, la tarjeta no debe estar vencida ni suspendida.

Para cada nuevo consumo se deben guardar los datos de una factura con el nombre y apellido, dirección, número de tarjeta, período de la factura, fecha de vencimiento, todas
las compras del período, y total a pagar.

Por último, se deben generar alertas por posibles fraudes. Existe un Call Center que ante cada alerta generada automáticamente realiza un llamado telefónico al cliente, indicándole la alerta detectada y verifica si se trató de un fraude ó no.
Se debe tener en cuenta para las alertas:

- Si una tarjeta registra dos compras en un lapso menor de un minuto en comercios distintos ubicados en el mismo código postal.
- Si una tarjeta registra dos compras en un lapso menor de 5 minutos en comercios con diferentes códigos postales.
- Si una tarjeta registra dos rechazos por exceso de límite en el mismo día, la tarjeta tiene que ser suspendida preventivamente.

//*(Longitud: 3–5 párrafos)*

== Descripción

En este apartado explicaremos las dificultades que tuvimos a lo largo de la realización del trabajo práctico.


//En esta sección pueden incluirse las dificultades que tuvieron, las soluciones encontradas, y las decisiones que fueron tomando a lo largo del trabajo práctico.

//También, se debe incluir una descripción general del programa—cómo funciona.

*(Longitud: 3–5 párrafos)*

== Implementación
A continuación se exponen los schemas de las tablas diseñadas como así la explicación de los atributos incorporados en dichas tablas. Además, se especificarán las correspondientes *Primary Key* (_PK_) y *Foreign Key* (_FK_) de cada tabla.

=== Tabla cliente
En primer lugar, diseñamos una tabla *cliente*, los atributos que tienen lugar en este modelo son el _dni_ que será el identificador único de dicha tabla, es decir, es la _primary key_. Luego, se tienen los datos necesarios del cliente, los cuales son el _nombre_, _apellido_ y la _dirección_, además, se debe especificar el _número de teléfono_ para que el Call Center pueda notificar al cliente de un posible fraude con su tarjeta.

[source, sql]
----
create table cliente(
        dni integer,
        nombre varchar(64),
        apellido varchar(64),
        direccion varchar(64),
        telefono integer
);   
----

Como nombramos anteriormente, el dni del cliente es una _primary key_ y agregamos este valor en la tabla con la siguiente sentencia:

[source, sql]
----
alter table cliente add constraint cliente_pk primary key (dni); 
----


=== Tabla tarjeta
*Tarjeta* es una tabla cuya _primary key_ es el número identificatorio de dicha tarjeta que consta de 16 dígitos, otro de los atributos de este schema es el propietario de la tarjeta, es decir,  el dni del cliente. Este sería la _FK_ de dicha tabla. 

//Aclaramos que el dni del cliente es la FK de la tarjeta y no de manera inversa, ya que en el enunciado se especifico que un cliente puede tener mas de una tarjeta.

Además, se tiene el _código de seguridad_ que consta de 3 a 4 dígitos dependiendo del banco, el _límite de compra_ diario de la tarjeta, es decir, el tope máximo que el banco financia a través de la tarjeta de crédito.
Colocamos un atributo denominado _fecha_vencimiento_ que se refiere a la fecha de expiracion de la tarjeta.

Por ultimo, el número de la tarjeta debe corresponder a una tarjeta vigente, no debe estar vencida, ni suspendida. La suspensión ocurre cuando la tarjeta registra dos rechazos por exceso de límite en el mismo dìa.

Para abarcar todos los estados de la tarjeta, incorporamos un atributo _estado_tarjeta_ en la tabla.

*falta agregar mas cosas*

[source,sql]
----
create table tarjeta(
       numero_tarjeta integer,
       dni_cliente integer,
       codigo_seguridad integer,
       limite_compra integer,
       saldo real,
       fecha_vencimiento date,
       estado_tarjeta varchar(64)      
);
----

El número de la tarjeta es la _PK_ de la tabla y se define de la siguiente manera:



Agregamos el dni del cliente como _FK_ ya que 

[source,sql]
----
alter table tarjeta add constraint tarjeta_fk0 foreign key (dni_cliente) references cliente(dni);
----


=== Tabla comercio
Agregamos la tabla *comercio* que consta de distintos atributos, un numero identificatorio de comercio que denominamos _codigo_comercio_, el nombre, dirección y el codigo postal de dicho comercio.
Colocamos el codigo postal del comercio en caso de emitir una alerta en el momento que la tarjeta registre compras en el mismo o diferente codigo postal de los comercios en el transcurso de un tiempo dado.

[source,sql]
----
create table comercio(
        codigo_comercio integer,
        nombre varchar(64),
        direccion varchar(64),
        codigo_postal integer
); 
----

Añadimos la _PK_ de la tabla comercio con la siguiente sentencia:

[source,sql]
----
alter table comercio add constraint comercio_pk primary key (codigo_comercio);
----

=== Tabla compra



=== Tabla factura


=== Tabla detalle



=== Tabla resumen



//En esta sección se incluye el código fuente correctamente formateado—y comentado, si corresponde. Además, por cada fragmento de código relevante—i.e. función, método, procedimiento—se debe dar una descripción general, decir qué hace, y especificar los parámetros que toma la función/método/procedimiento, junto con los valores que devuelve ó modifica.

//_No debería incluirse el código de librerías/frameworks que se utilicen—a no ser que sea absolutamente necesario._

*(Longitud: lo que sea necesario)*

== Conclusiones

//Aquí van algunas reflexiones acerca del proceso de desarrollo del trabajo realizado, y de los resultados obtenidos. También se debe incluir una conclusión final de producto terminado.

//Pueden incluirse lecciones aprendidas durante el desarrollo del trabajo.

*(Longitud: 1–3 párrafos)*
